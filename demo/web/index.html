<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8" />
  <title>Live Context ASR Demo</title>
  <style>
    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      margin: 16px;
      background: #0b0c10;
      color: #e5e5e5;
    }

    h1 {
      margin-top: 0;
      font-size: 20px;
    }

    .controls {
      margin-bottom: 12px;
    }

    button {
      padding: 6px 12px;
      margin-right: 8px;
      border-radius: 4px;
      border: none;
      cursor: pointer;
      background: #1f4068;
      color: #fff;
    }

    button:disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }

    #status {
      display: inline-block;
      margin-left: 8px;
      font-size: 13px;
    }

    .status-pill {
      display: inline-block;
      padding: 2px 8px;
      border-radius: 999px;
      font-size: 11px;
      margin-left: 4px;
    }

    .status-ok {
      background: #145c32;
      color: #c8f7c5;
    }

    .status-bad {
      background: #6b1b25;
      color: #f8c6ce;
    }

    .layout {
      display: grid;
      grid-template-columns: 2fr 1.2fr;
      grid-gap: 12px;
      margin-top: 12px;
    }

    .panel {
      border-radius: 6px;
      padding: 8px;
      background: #141722;
      border: 1px solid #222632;
      overflow: hidden;
    }

    .panel h2 {
      margin: 0 0 6px 0;
      font-size: 14px;
      text-transform: uppercase;
      letter-spacing: 0.06em;
      color: #a0a7bd;
    }

    #transcript {
      font-size: 14px;
      line-height: 1.5;
      white-space: pre-wrap;
      word-wrap: break-word;
      max-height: 420px;
      overflow-y: auto;
    }

    .utt-line {
      display: block;
      margin-bottom: 4px;
    }

    .utt-final {
      color: #e5e5e5;
    }

    .utt-partial {
      color: #c0c6df;
    }

    .utt-meta {
      font-size: 11px;
      color: #7b8198;
      margin-right: 4px;
    }

    #finalList {
      font-size: 13px;
      line-height: 1.4;
      max-height: 200px;
      overflow-y: auto;
    }

    #factCheckList {
      font-size: 13px;
      line-height: 1.4;
      max-height: 220px;
      overflow-y: auto;
    }

    .final-item {
      margin-bottom: 6px;
      padding-bottom: 4px;
      border-bottom: 1px solid #222632;
    }

    .final-meta {
      font-size: 11px;
      color: #9aa0b8;
      margin-bottom: 2px;
    }

    .tag {
      display: inline-block;
      padding: 1px 6px;
      border-radius: 999px;
      font-size: 10px;
      margin-right: 4px;
    }

    .tag-ready {
      background: #145c32;
      color: #c8f7c5;
    }

    .tag-skip {
      background: #3a3f4f;
      color: #c0c4d4;
    }

    #log {
      font-family: "SF Mono", Menlo, Consolas, monospace;
      font-size: 11px;
      background: #050608;
      color: #c4c4c4;
      padding: 6px;
      border-radius: 4px;
      max-height: 260px;
      overflow-y: auto;
      white-space: pre-wrap;
    }

    /* Screen-share preview (bottom-right) */
    #screenPreviewContainer {
      position: fixed;
      bottom: 16px;
      right: 16px;
      width: 280px;
      height: 158px; /* ~16:9 */
      background: #000;
      border-radius: 6px;
      overflow: hidden;
      border: 1px solid #222632;
      box-shadow: 0 6px 16px rgba(0, 0, 0, 0.6);
      z-index: 1000;
      display: none; /* shown only when sharing */
    }

    #screenPreview {
      width: 100%;
      height: 100%;
      object-fit: contain;
      background: #000;
      display: block;
    }
  </style>
</head>
<body>
  <h1>Live Context – Screen Share ASR</h1>

  <div class="controls">
    <button id="connectBtn">Connect WS</button>
    <button id="shareBtn" disabled>Start Screen Share (with audio)</button>
    <span id="status">
      WS: <span id="wsStatusPill" class="status-pill status-bad">DISCONNECTED</span>
    </span>
  </div>

  <div class="layout">
    <!-- Left: evolving transcript -->
    <div class="panel">
      <h2>Transcript (live)</h2>
      <div id="transcript">– waiting for audio –</div>
      <h2 style="margin-top: 10px;">Fact Check Results</h2>
      <div id="factCheckList"></div>
    </div>

    <!-- Right: debug log -->
    <div class="panel">
      <h2>Debug Log</h2>
      <div id="log"></div>
    </div>
  </div>

  <script>
    let ws = null;
    let audioContext = null;
    let processor = null;

    const wsStatusPill = document.getElementById("wsStatusPill");
    const transcriptEl = document.getElementById("transcript");
    const logEl = document.getElementById("log");
    const factCheckListEl = document.getElementById("factCheckList");
    const screenPreviewContainer = document.createElement("div");
    const screenPreviewVideo = document.createElement("video");

    // Build preview container dynamically to avoid altering layout structure.
    screenPreviewContainer.id = "screenPreviewContainer";
    screenPreviewVideo.id = "screenPreview";
    screenPreviewVideo.autoplay = true;
    screenPreviewVideo.muted = true;
    screenPreviewVideo.playsInline = true;
    screenPreviewContainer.appendChild(screenPreviewVideo);
    document.body.appendChild(screenPreviewContainer);

    // utteranceId -> { id, speaker, tStart, tEnd, finalText, latestText, isFinal, quality }
    const utterances = new Map();

    function log(msg) {
      console.log(msg);
      logEl.textContent += msg + "\n";
      logEl.scrollTop = logEl.scrollHeight;
    }

    function setWsStatus(connected) {
      if (connected) {
        wsStatusPill.textContent = "CONNECTED";
        wsStatusPill.classList.remove("status-bad");
        wsStatusPill.classList.add("status-ok");
      } else {
        wsStatusPill.textContent = "DISCONNECTED";
        wsStatusPill.classList.remove("status-ok");
        wsStatusPill.classList.add("status-bad");
      }
    }

    function formatSeconds(sec) {
      if (sec === undefined || isNaN(sec)) return "??:??";
      const s = Math.max(0, Math.floor(sec));
      const m = Math.floor(s / 60);
      const r = s % 60;
      return `${m.toString().padStart(2, "0")}:${r.toString().padStart(2, "0")}`;
    }

    function getTextPayload(msg) {
      if (!msg) return "";
      if (typeof msg.text === "string" && msg.text.length > 0) return msg.text;
      if (typeof msg.raw_text === "string" && msg.raw_text.length > 0) return msg.raw_text;
      return "";
    }

    function withTrailingSpace(text) {
      if (!text) return "";
      return text.endsWith(" ") ? text : `${text} `;
    }

    function resetSessionState() {
      utterances.clear();
      transcriptEl.textContent = "– waiting for audio –";
    }

    function upsertUtteranceFromPartial(msg) {
      const id = msg.utterance_id;
      const q = msg.quality || {};
      const existing = utterances.get(id) || {
        id,
        speaker: msg.speaker || "UNKNOWN",
        tStart: msg.t_start ?? 0,
        tEnd: msg.t_end ?? 0,
        finalText: null,
        latestText: "",
        isFinal: false,
        quality: q
      };

      existing.speaker = msg.speaker || existing.speaker || "UNKNOWN";
      existing.latestText = getTextPayload(msg);
      existing.tStart = (msg.t_start !== undefined) ? msg.t_start : existing.tStart;
      existing.tEnd = (msg.t_end !== undefined) ? msg.t_end : existing.tEnd;
      existing.isFinal = false;
      existing.quality = q;
      utterances.set(id, existing);
    }

    function upsertUtteranceFromFinal(msg) {
      const id = msg.utterance_id;
      const q = msg.quality || {};
      const existing = utterances.get(id) || {
        id,
        speaker: msg.speaker || "UNKNOWN",
        tStart: msg.t_start ?? 0,
        tEnd: msg.t_end ?? 0,
        finalText: null,
        latestText: "",
        isFinal: false,
        quality: q
      };

      existing.speaker = msg.speaker || existing.speaker || "UNKNOWN";
      const finalText = getTextPayload(msg);
      existing.finalText = finalText;
      existing.latestText = finalText;
      existing.tStart = (msg.t_start !== undefined) ? msg.t_start : existing.tStart;
      existing.tEnd = (msg.t_end !== undefined) ? msg.t_end : existing.tEnd;
      existing.isFinal = true;
      existing.quality = q;
      utterances.set(id, existing);
    }

    // Continuous transcript: all finals rendered as stable text + a single live partial tail.
    function renderTranscript() {
      if (utterances.size === 0) {
        transcriptEl.textContent = "– waiting for audio –";
        return;
      }

      const items = Array.from(utterances.values())
        .sort((a, b) => (a.tStart ?? 0) - (b.tStart ?? 0));

      const finalUtterances = [];
      let currentPartial = null;

      for (const item of items) {
        const hasText = (item.finalText && item.finalText.length > 0) || (item.latestText && item.latestText.length > 0);
        if (!hasText) continue;

        if (item.isFinal && item.finalText) {
          finalUtterances.push(item);
        } else if (!item.isFinal && item.latestText) {
          if (!currentPartial || (item.tStart ?? 0) >= (currentPartial.tStart ?? 0)) {
            currentPartial = item;
          }
        }
      }

      if (finalUtterances.length === 0 && !currentPartial) {
        transcriptEl.textContent = "– waiting for audio –";
        return;
      }

      transcriptEl.innerHTML = "";
      const fragment = document.createDocumentFragment();

      // Group consecutive final utterances by speaker so each speaker turn
      // renders as a single line of text.
      const groupedFinals = [];
      for (const u of finalUtterances) {
        const speakerKey = u.speaker || "UNKNOWN";
        const text = u.finalText || u.latestText || "";

        if (groupedFinals.length === 0 || groupedFinals[groupedFinals.length - 1].speaker !== speakerKey) {
          groupedFinals.push({
            speaker: speakerKey,
            tStart: u.tStart,
            tEnd: u.tEnd,
            utteranceIds: [u.id],
            texts: [text],
          });
        } else {
          const last = groupedFinals[groupedFinals.length - 1];
          last.utteranceIds.push(u.id);
          last.texts.push(text);
          last.tEnd = u.tEnd;
        }
      }

      for (const group of groupedFinals) {
        const line = document.createElement("div");
        line.className = "utt-line utt-final";

        const speakerLabel = group.speaker && group.speaker !== "UNKNOWN"
          ? `${group.speaker.toUpperCase()}: `
          : "";

        const combinedText = withTrailingSpace(group.texts.join(" ").trim());
        line.textContent = speakerLabel + combinedText;
        line.dataset.utteranceIds = group.utteranceIds.join(",");
        line.dataset.speaker = group.speaker || "";
        line.dataset.tStart = group.tStart;
        line.dataset.tEnd = group.tEnd;
        fragment.appendChild(line);
      }

      if (currentPartial) {
        const line = document.createElement("div");
        line.className = "utt-line utt-partial";

        const speakerLabel = currentPartial.speaker && currentPartial.speaker !== "UNKNOWN"
          ? `${currentPartial.speaker.toUpperCase()}: `
          : "";

        line.textContent = speakerLabel + (currentPartial.latestText || "");
        line.dataset.utteranceId = currentPartial.id;
        line.dataset.speaker = currentPartial.speaker || "";
        line.dataset.tStart = currentPartial.tStart;
        line.dataset.tEnd = currentPartial.tEnd;
        line.dataset.confidence = currentPartial.quality?.avg_confidence ?? "";
        line.dataset.wordCount = currentPartial.quality?.word_count ?? "";
        line.dataset.langchainReady = currentPartial.quality?.langchain_ready ?? "false";
        fragment.appendChild(line);
      }

      transcriptEl.appendChild(fragment);
      transcriptEl.scrollTop = transcriptEl.scrollHeight;
    }

    // Basic markdown link support: [text](https://example.com)
    function renderMarkdownWithLinks(text) {
      if (!text) return "";
      // Escape HTML to avoid accidental injection, then re-insert links.
      const esc = text
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;");
      return esc.replace(
        /\[([^\]]+)\]\((https?:\/\/[^\s)]+)\)/g,
        '<a href="$2" target="_blank" rel="noopener noreferrer">$1</a>'
      );
    }

    function appendFactCheckResult(msg) {
      if (!factCheckListEl) return;

      const payload = msg.payload || {};

      const claim =
        msg.query || payload.query || "No claim text provided";

      const classification =
        payload.Classification || msg.classification || "unknown";

      const fullAssessment =
        payload.overall_assessment || msg.overall_assessment || "";

      // Split assessment vs evidence by blank line(s), if present
      let assessment = fullAssessment;
      let evidence = "";
      if (fullAssessment && /\n\n+/.test(fullAssessment)) {
        const parts = fullAssessment.split(/\n\n+/);
        assessment = parts[0] || "";
        evidence = parts.slice(1).join("\n\n");
      }

      const disambiguation = payload.disambiguation || "";
      const biasList = payload.bias || [];

      // Outer container for each claim
      const container = document.createElement("div");
      container.className = "final-item";

      // Header row (clickable)
      const header = document.createElement("div");
      header.style.display = "flex";
      header.style.alignItems = "center";
      header.style.justifyContent = "space-between";
      header.style.cursor = "pointer";

      // Classification pill
      const pill = document.createElement("span");
      const clsLower = String(classification).toLowerCase();
      const isTrueish =
        clsLower.includes("true") || clsLower.includes("supported");

      pill.className = "tag " + (isTrueish ? "tag-ready" : "tag-skip");
      pill.textContent = classification;

      // Short claim preview
      const claimPreview = document.createElement("div");
      claimPreview.style.marginLeft = "8px";
      claimPreview.style.fontSize = "12px";
      claimPreview.style.whiteSpace = "nowrap";
      claimPreview.style.overflow = "hidden";
      claimPreview.style.textOverflow = "ellipsis";
      claimPreview.textContent = claim;

      // Simple chevron indicator
      const chevron = document.createElement("span");
      chevron.style.marginLeft = "8px";
      chevron.style.fontSize = "11px";
      chevron.textContent = "▶";

      const left = document.createElement("div");
      left.style.display = "flex";
      left.style.alignItems = "center";
      left.appendChild(pill);
      left.appendChild(claimPreview);

      header.appendChild(left);
      header.appendChild(chevron);

      container.appendChild(header);

      // Detail panel (initially hidden)
      const detail = document.createElement("div");
      detail.style.marginTop = "6px";
      detail.style.fontSize = "12px";
      detail.style.whiteSpace = "pre-wrap"; // keep newlines
      detail.hidden = true;

      function addField(label, value, { allowMarkdownLinks = false } = {}) {
        if (!value) return;

        const row = document.createElement("div");
        row.style.marginBottom = "4px";

        const title = document.createElement("div");
        title.style.fontWeight = "600";
        title.style.marginBottom = "2px";
        title.textContent = label;

        const body = document.createElement("div");
        if (allowMarkdownLinks) {
          body.innerHTML = renderMarkdownWithLinks(value);
        } else {
          body.textContent = value;
        }

        row.appendChild(title);
        row.appendChild(body);
        detail.appendChild(row);
      }

      // 1) Claim
      addField("1) Claim", claim);

      // 2) Classification
      addField("2) Classification", classification);

      // 3) Assessment (may contain markdown links)
      addField("3) Assessment", assessment, { allowMarkdownLinks: true });

      // 4) Disambiguation (may contain markdown links)
      addField("4) Disambiguation", disambiguation, { allowMarkdownLinks: true });

      // 5) Evidence (may contain markdown links)
      addField("5) Evidence", evidence, { allowMarkdownLinks: true });

      // Optional: source bias summary (under Evidence)
      if (biasList.length) {
        const sources = biasList
          .map((b) => {
            const biasVal =
              typeof b.Bias === "number" ? b.Bias.toFixed(2) : "?";
            const qualVal =
              typeof b.Quality === "number" ? b.Quality.toFixed(1) : "?";
            return `${b.url} (bias=${biasVal}, quality=${qualVal})`;
          })
          .join(" • ");

        const row = document.createElement("div");
        row.style.marginTop = "4px";
        row.style.fontSize = "11px";
        row.style.color = "#9aa0b8";
        row.textContent = `Sources: ${sources}`;
        detail.appendChild(row);
      }

      container.appendChild(detail);

      // Toggle detail on header click
      header.onclick = () => {
        const isHidden = detail.hidden;
        detail.hidden = !isHidden;
        chevron.textContent = isHidden ? "▼" : "▶";
      };

      // Newest on top
      factCheckListEl.prepend(container);
    }

    document.getElementById("connectBtn").onclick = () => {
      if (ws && ws.readyState === WebSocket.OPEN) {
        log("WebSocket already connected");
        return;
      }

      ws = new WebSocket("ws://localhost:8765");
      ws.binaryType = "arraybuffer";

      ws.onopen = () => {
        log("✅ WebSocket connected");
        setWsStatus(true);
        document.getElementById("shareBtn").disabled = false;
      };

      ws.onclose = () => {
        log("❌ WebSocket closed");
        setWsStatus(false);
        document.getElementById("shareBtn").disabled = true;
      };

      ws.onerror = (e) => {
        log("❌ WebSocket error");
        console.error(e);
      };

      ws.onmessage = (e) => {
        try {
          const msg = JSON.parse(e.data);

          if (msg.type === "partial_utterance") {
            upsertUtteranceFromPartial(msg);
            renderTranscript();
          } else if (msg.type === "final_utterance") {
            upsertUtteranceFromFinal(msg);
            renderTranscript();
          } else if (msg.type === "session_started") {
            resetSessionState();
            log("Session started: " + JSON.stringify(msg.config));
          } else if (msg.type === "session_stopped") {
            log("Session stopped");
          } else if (msg.type === "context_window_ready") {
            const q = msg.quality || {};
            const wc = q.word_count ?? "?";
            const conf = q.avg_confidence !== undefined ? q.avg_confidence.toFixed(2) : "?";
            log(`[CTX][${msg.window_id}] wc=${wc} conf=${conf}\n${msg.text}`);
          } else if (msg.type === "fact_check_result") {
            appendFactCheckResult(msg);
            // Log full payload for debugging
            log("Fact-check payload:\n" + JSON.stringify(msg, null, 2));
          } else {
            log("Event: " + e.data);
          }
        } catch (err) {
          // Non-JSON fallback
          log("Server message: " + e.data);
        }
      };
    };

    document.getElementById("shareBtn").onclick = async () => {
      if (!ws || ws.readyState !== WebSocket.OPEN) {
        log("WebSocket not connected");
        return;
      }

      let screenStream;
      let micStream;
      try {
        screenStream = await navigator.mediaDevices.getDisplayMedia({
          video: true,
          audio: true
        });
      } catch (err) {
        log("Failed to start screen share: " + err);
        return;
      }

      try {
        micStream = await navigator.mediaDevices.getUserMedia({
          audio: {
            echoCancellation: true,
            noiseSuppression: true,
            autoGainControl: true
          }
        });
      } catch (err) {
        log("Failed to access microphone: " + err);
        return;
      }

      log("Screen share started");

      // Show preview of the shared tab/window in the bottom-right.
      try {
        screenPreviewVideo.srcObject = screenStream;
        screenPreviewContainer.style.display = "block";

        const hidePreview = () => {
          screenPreviewVideo.srcObject = null;
          screenPreviewContainer.style.display = "none";
        };

        // Hide when any track ends (user stops sharing from browser UI).
        screenStream.getTracks().forEach(track => {
          track.addEventListener("ended", hidePreview, { once: true });
        });
      } catch (e) {
        console.error("Error attaching stream to preview video", e);
      }

      // Audio pipeline in browser → stereo PCM16 (ch0=mic, ch1=system) → WS
      audioContext = new (window.AudioContext || window.webkitAudioContext)();

      const micSource = audioContext.createMediaStreamSource(micStream);
      const sysSource = audioContext.createMediaStreamSource(screenStream);

      // Merge into a 2-channel node: mic -> channel 0, system -> channel 1.
      const merger = audioContext.createChannelMerger(2);
      micSource.connect(merger, 0, 0);
      sysSource.connect(merger, 0, 1);

      const bufferSize = 4096;
      const inputChannels = 2;
      const outputChannels = 2;
      processor = audioContext.createScriptProcessor(bufferSize, inputChannels, outputChannels);

      processor.onaudioprocess = (audioEvent) => {
        const inputBuffer = audioEvent.inputBuffer;
        const ch0 = inputBuffer.getChannelData(0); // mic
        // Some browsers may downmix; guard with fallback to ch0.
        const ch1 = inputBuffer.numberOfChannels > 1 ? inputBuffer.getChannelData(1) : ch0; // system

        const pcm16 = floatStereoTo16BitPCM(ch0, ch1);

        if (ws && ws.readyState === WebSocket.OPEN) {
          ws.send(pcm16.buffer);
        }
      };

      // Connect graph; keep destination connection to ensure processing runs.
      merger.connect(processor);
      processor.connect(audioContext.destination);

      log("Streaming audio (mic+system) to server...");
    };

    function floatStereoTo16BitPCM(ch0, ch1) {
      const len = Math.min(ch0.length, ch1.length);
      const pcm16 = new Int16Array(len * 2); // interleaved stereo
      for (let i = 0; i < len; i++) {
        let l = Math.max(-1, Math.min(1, ch0[i]));
        let r = Math.max(-1, Math.min(1, ch1[i]));
        pcm16[2 * i] = l < 0 ? l * 0x8000 : l * 0x7fff;
        pcm16[2 * i + 1] = r < 0 ? r * 0x8000 : r * 0x7fff;
      }
      return pcm16;
    }
  </script>
</body>
</html>
